[Лаба5.md](https://github.com/user-attachments/files/23567317/5.md)
# Андреева Любовь ИТ-7 Лабораторная №5

# Задание 1
## Задача 1
### Текст задачи 
 В класс Дробь, добавить интерфейс на два метода: получение вещественного значения, установка
числителя и установка знаменателя.
Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного
значения.
Если раннее в вашем варианте не было Дроби, то создайте сущность Дробь со следующими
особенностями:
• Имеет числитель: целое число
• Имеет знаменатель: целое число
• Дробь может быть создана с указанием числителя и знаменателя
• Может вернуть строковое представление вида “числитель/знаменатель”
• Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель не может
быть отрицательным.
• Переопределите метод сравнения объектов по состоянию таким образом, чтобы две дроби
считались одинаковыми тогда, когда у них одинаковые значения числителя и знаменателя.
### Алгоритм решения
1. Создать интерфейс FractionInterface
Объявить методы:
getValue() — вернуть вещ. значение дроби;
setNumerator(int numerator) — установить числитель;
setDenominator(int denominator) — установить знаменатель.
2. Создать класс Fraction, реализующий интерфейс
Добавить поля numerator и denominator.
В конструкторе Fraction:
сохранить числитель;
проверить, что знаменатель не равен 0;
сохранить знаменатель;
если знаменатель < 0, изменить знак числителя и знаменателя.
Реализовать toString():
вернуть строку "числитель/знаменатель".
Переопределить equals():
считать дроби равными, если одинаковы числитель и знаменатель.
3. Создать класс CachedFraction, наследующий Fraction
Добавить поле cachedValue, изначально null.
если cachedValue == null, вычислить super.getValue() и сохранить;
вызвать версию родителя;
сбросить кэш (cachedValue = null).
4. В методе main:
Считать числитель и знаменатель;
Создать объект CachedFraction и:
вывести его;
вызвать первый раз (вычисляется);
вызвать второй раз (берётся из кэша).
Изменить числитель методом setNumerator(10):
вывести новую дробь;
снова вызвать (кэш пересчитан).
Создать новую дробь Fraction(10, denominator):
сравнить с cachedFraction через equals();
вывести результат сравнения.

# Задание 2
## Задача 1
Количество мяуканий.
Необходимо воспользоваться классом Кот и методом принимающим всех мяукающих из задачи 2.5.4.
Необходимо таким образом передать кота в указанный метод, что бы после окончания его работы
узнать сколько раз мяукал кот за время его работы. На рисунке показан пример работы. Перед вызовом
метода создаем кота, отправляем ссылку на кота в метод, после окончания его работы выводим
количество мяуканий на экран. Кота изменять нельзя.
Если раннее в вашем варианте не было Кота, то создайте
1. сущность Кот, которая описывается следующим образом:
• Имеет Имя (строка)
• Для создания необходимо указать имя кота.
• Может быть приведен к текстовой форме вида: “кот: Имя”
• Может помяукать, что приводит к выводу на экран следующего текста: “Имя: мяу!”,
вызвать мяуканье можно без параметров.
2. интерфейс Мяуканье: разработайте метод, который принимает набор объектов способных
мяукать и вызывает мяуканье у каждого объекта. Мяукающие объекты должны иметь метод со
следующей сигнатурой:
public void meow();
### Алгоритм решения
1. Создать интерфейс Meowable
Объявить метод:
meow() — выполняет мяуканье объекта.
2. Создать класс Cat, реализующий Meowable
Добавить поле name.
В конструкторе Cat(String name):
сохранить имя кота.
Реализовать метод meow():
выводить на экран "Имя: мяу!".
Реализовать toString():
возвращать "кот: Имя".
3. Создать класс MeowCounter, реализующий Meowable
Добавить поле original — объект, который должен мяукать.
Добавить поле count, изначально 0.
В конструкторе MeowCounter(Meowable original):
сохранить ссылку на оригинальный объект.
В методе meow():
увеличить count;
вызвать original.meow().
Создать метод getCount():
возвращает количество вызовов meow().
Переопределить toString():
возвращать строку вида "кот: Имя (мяукал X раз)".
4. Создать утилитный класс MeowUtils
Реализовать статический метод makeAllMeow(Meowable... meowables):
пройти циклом по каждому объекту;
вызвать у него meow().
5. В методе main:
Считать имя кота.
Создать объект Cat с этим именем.
Обернуть кота в MeowCounter, создав объект counter.
Передать counter в MeowUtils.makeAllMeow() нужное количество раз.
Вывести:
"Кот мяукнул всего X раз(а)", используя counter.getCount().

# Задание 3
## Задача 3
### Текст задачи
Даны упорядоченные списки L1 и L2. Вставить элементы списка L2 в список L1, не нарушая его
упорядоченности.
### Алгоритм решения
1. Создать класс OrderedList
Добавить поле elements — список целых чисел.
В конструкторе без параметров:
создать пустой список.
В конструкторе OrderedList(int[] initialElements):
создать пустой список;
для каждого числа массива вызвать insert(value).
2. Реализовать метод insert(int value)
Найти позицию, где новый элемент должен быть размещён, чтобы сохранить упорядоченность:
пока текущий элемент списка меньше вставляемого — переходить дальше;
Вставить новое число в найденную позицию.
3. Реализовать метод insertAll(OrderedList other)
Пройти по всем элементам списка other;
Для каждого числа вызвать метод insert(value) текущего списка;
Тогда элементы L2 окажутся вставлены в L1 без нарушения порядка.
4. В методе main:
Считать размер L1 и его элементы.
Создать OrderedList list1 на основе введенных чисел.
Считать размер L2 и его элементы.
Создать OrderedList list2.
Вывести оба списка на экран.
Вызвать list1.insertAll(list2) — вставить элементы L2 в L1.
Вывести объединённый упорядоченный список.

# Задание 4
## Задача 3
### Текст задачи
 На вход программы подаются сведения о результатах соревнований по школьному многоборью.
Многоборье состоит из соревнований по четырем видам спорта, участие в каждом из которых
оценивается баллами от 0 до 10 (0 баллов получает ученик, не принимавший участия в
соревнованиях по данному виду спорта). Победители определяются по наибольшей сумме
набранных баллов. Известно, что общее количество участников соревнований не превосходит
100.
В первой строке вводится количество учеников, принимавших участие в соревнованиях, N. Далее
следуют N строк, имеющих следующий формат:
<Фамилия><Имя><Баллы>
Здесь <Фамилия>– строка, состоящая не более чем из 20 символов;<Имя>– строка, состоящая не
более чем из 15 символов;<Баллы> - строка, содержащая четыре целых числа, разделенных
пробелом, соответствующих баллам, полученным на соревнованиях по каждому из четырех
видов спорта. При этом <Фамилия> и <Имя>, <Имя> и <Баллы> разделены одним пробелом.
Примеры входных строк:
Иванова Мария 5 8 6 3
Петров Сергей 9 9 5 7
Напишите программу, которая будет выводить на экран фамилии и имена трех лучших
участников многоборья. Если среди остальных участников есть ученики, набравшие то же
количество баллов, что и один из трех лучших, то их фамилии и имена также следует вывести.
При этом имена и фамилии можно выводить в произвольном порядке.
### Алгоритм решения
1. Создаем класс Participant (Участник):
String lastName – фамилия
String firstName – имя
int[] scores – массив из 4-х оценок по видам спорта
int getTotalScore() – метод, возвращающий сумму баллов
String getFullName() – возвращает "Фамилия Имя"
toString() – текстовое представление участника
2. Создаем класс CompetitionProcessor
Свойства:
List<Participant> participants – список участников
Методы:
void readParticipants(String fileName) – чтение участников из файла:
Считываем каждую строку
Разделяем строку на фамилию, имя и оценки
Проверяем корректность данных (число оценок = 4, значения 0–10)
Добавляем нового Participant в список
List<Participant> getTopParticipants(int topN) – получение топ-участников:
Сортируем список по getTotalScore() в порядке убывания
Берем первых topN участников
Определяем минимальный балл среди топ-N
Добавляем всех участников, у которых сумма баллов ≥ минимального топ-N
3.Выводим участников в читаемом виде (фамилия + имя + сумма баллов)

# Задание 5
## Задача 7
### Текст задачи
Файл содержит текст на русском языке. Сколько разных букв встречается в тексте?
### Алгоритм решения
1. Создать класс LetterCounter
Добавить поле fileName — имя файла.
Добавить поле uniqueLettersCount — количество уникальных русских букв.
В конструкторе LetterCounter(String fileName):
проверить, что имя файла не пустое;
сохранить имя файла;
установить счётчик уникальных букв в 0.
2. Реализовать метод countLetters()
Создать множество Set<Character> для хранения уникальных букв.
Открыть файл через BufferedReader и читать его символ за символом.
Для каждого символа:
привести его к типу char;
проверить через isRussianLetter(ch), является ли он русской буквой
(А–Я, а–я, Ё, ё);
если да — добавить букву в множество в нижнем регистре.
После завершения чтения:
сохранить размер множества в uniqueLettersCount.
3. Реализовать метод isRussianLetter(char ch)
Проверять, принадлежит ли символ диапазону 'А'–'я' или равен 'Ё' или 'ё'.
4. Реализовать метод getUniqueLettersCount()
Вернуть uniqueLettersCount.
5. В методе main:
Создать объект LetterCounter, передав имя файла (у меня - students.txt)
В блоке try вызвать letterCounter.countLetters().
Вывести результат.

# Задание 6
## Задача 2
### Текст задачи
По списку L построить очередь (например, по списку из элементов 1, 2, 3 требуется построить
очередь из элементов 1, 2, 3, 3, 2, 1).
### Алгоритм решения
1. Создать класс QueueBuilder
Добавить поле sourceList — исходный массив целых чисел
Добавить поле resultQueue — очередь Queue<Integer> для результата.
В конструкторе QueueBuilder(int[] sourceList):
проверить, что массив не пустой;
сохранить исходный список;
создать пустую очередь resultQueue.
2. Реализовать метод buildQueue()
Очистить resultQueue.
Добавить в очередь элементы sourceList в прямом порядке.
Добавить в очередь элементы sourceList в обратном порядке.
3. Реализовать метод getResultQueue()
Вернуть очередь resultQueue.
4. Переопределить toString()
Вывести содержимое sourceList и resultQueue в читаемом виде.
5. В методе main выполнить следующие действия
Считать размер списка L и элементы массива sourceArray.
Создать объект QueueBuilder с массивом sourceArray.
Вызвать метод buildQueue() для построения очереди.
Вывести полученную очередь через getResultQueue().

# Задание 7
## Задача 1
### Текст задачи
Необходимо написать стрим:
Дан набор объектов типа Point, необходимо взять все Point в разных координатах, убрать с
одинаковыми X,Y, отсортировать по X, отрицательные Y сделать положительными и собрать это
все в ломаную (объект типа Polyline)
Если раннее в вашем варианте не было задание с классом Point и Polyline, то написать их:
1. класс Point:
• Координата Х: число.
• Координата Y: число.
• Может возвращать текстовое представление вида “{X;Y}”.
2. класс Line (Линия), расположенная на двумерной плоскости, которая описывается:
• Координата начала: Точка
• Координата конца: Точка
• Может возвращать текстовое представление вида “Линия от {X1;Y1} до {X2;Y2}”
3. класс Polyline (Ломаная), которая будет представлять собой ломаную линию. Ломаная
линия представляет собой набор следующих характеристик:
• Имеет массив Точек, через которые линия проходит.
• Может быть приведена к строковой форме вида “Линия [Т1,T2,…,TN]”, где TN – это
результат приведения к строке Точки с номером N
### Алгоритм решения
1. Создать класс Point
Поля x и y — координаты точки.
Конструктор Point(double x, double y) для инициализации.
Геттеры и сеттеры для x и y.
Переопределить toString() для вывода в виде {X;Y}.
Переопределить equals() и hashCode() для корректного сравнения точек и работы distinct().
2. Создать класс Polyline
Поле points — массив Point[].
Конструктор Polyline(Point[] points), проверяющий, что массив не пустой.
Метод getPoints() для получения массива точек.
Переопределить toString() для вывода вида Линия [Т1, Т2, …, TN].
3. В методе main:
Создать массив объектов Point[] points (с исходными координатами).
Построить объект Polyline с помощью стрима:
Пройтись по всем точкам массива points.
Преобразовать координату Y в положительную (Math.abs).
Убрать дубликаты (distinct()), учитывая и X, и Y.
Отсортировать точки по X (sorted).
Собрать результат в массив Point[] и передать в конструктор Polyline.
Вывести ломаную.

## Задача 2
### Текст задачи 
Дан текстовый файл со строками, содержащими имя человека и его номер в следующей форме:
Вася:5
Петя:3
Аня:5
Номера людей могут повторяться. У каких-то людей может не быть номера.
Необходимо написать стрим выполняющую следующее:
читаются все люди из файла, все имена приводится к нижнему регистру, но с первой буквой в
верхнем регистре, убираем из перечня всех людей без номеров, а имена оставшихся группируются
по их номеру:
[5:[Вася, Аня], 3:[Петя]]
### Алгоритм решения
1. Создать класс PersonNumber
Поля:
String name — имя человека.
Integer number — номер, может быть null, если номера нет.
Конструктор PersonNumber(String name, Integer number):
Приводит имя к виду с заглавной первой буквой (capitalize).
Сохраняет номер (может быть null).
Методы:
getName() — возвращает имя.
getNumber() — возвращает номер.
Переопределить toString() для наглядного вывода, например Вася:5 или Петя:нет номера.
2. Создать класс PersonNumberProcessor
Поля:
String fileName — имя файла.
List<PersonNumber> persons — список всех людей из файла.
Методы:
readFile():
Открывает файл по имени fileName.
Считывает построчно.
Разделяет строку по : на имя и номер.
Если номер отсутствует или некорректный → оставляет number = null.
Создает объект PersonNumber и добавляет в список persons.
groupByNumber():
Стрим по persons.
Фильтрует только людей с ненулевым номером (filter(p -> p.getNumber() != null)).
Приводит имена к правильному регистру (уже сделано в конструкторе PersonNumber).
Группирует по номеру в Map<Integer, List<String>> с сохранением порядка появления.
3. В методе main:
Создать объект PersonNumberProcessor, передав имя файла.
Вызвать метод readFile() для считывания всех данных.
Вызвать groupByNumber() для группировки людей по номерам.
Вывести результат на экран.
